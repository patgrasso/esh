# esh

`esh(1)` is an enhanced version of `envsubst(1)` that evaluates more than just
environment variables, but also whole bash-like expressions. For example,

```bash
Hello ${RECIPIENT},

Your machine $(hostname) is seeing an abnormally high amount of usage.

Processes using the most memory:
$(ps aux --sort=-%mem | awk 'NR<=6{FS=" "; OFS="\t"; print $1, $4, $11}')

Processes using the most cycles:
$(ps aux --sort=-%cpu | awk 'NR<=6{FS=" "; OFS="\t"; print $1, $3, $11}')

Regards,
System Administrator
```

will become something like the following:

```
Hello Josh,

Your machine localhost is seeing an abnormally high amount of usage.

Processes using the most memory:
USER	%MEM	COMMAND
user	11.1	/opt/google/chrome/chrome
user	10.1	/opt/google/chrome/chrome
user	8.9	/opt/google/chrome/chrome
user	8.5	/opt/google/chrome/chrome
user	7.1	/opt/google/chrome/chrome

Processes using the most cycles:
USER	%CPU	COMMAND
user	7.2	/opt/google/chrome/chrome
user	5.7	/opt/google/chrome/nacl_helper
user	2.4	/opt/google/chrome/chrome
user	1.1	/opt/google/chrome/chrome
user	1.1	/opt/google/chrome/chrome

Regards,
System Administrator
```

As you may have guessed, this was inspired by ruby's `erb(1)`.


## Building
- `make`          - build executable
- `make debug`    - build debug executable (prints debug information from yacc)
- `make [f]clean` - cleans up object files and files generated by yacc & lex

See `Makefile` for more about each target.


## License
MIT
